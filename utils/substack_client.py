# utils/substack_client.py

import logging
import tempfile
import time
import calendar
from .config import SUBSTACK_COOKIE, SUBSTACK_PUBLICATION_URL

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

class SubstackClient:
    """
    Reads SUBSTACK_COOKIE ("name=value") from .env, writes a minimal Netscape
    cookie file to a temporary .txt, then initializes Api(cookies_path=...).
    """

    def __init__(self):
        if not (SUBSTACK_COOKIE and SUBSTACK_PUBLICATION_URL):
            missing = [
                key for key, val in (
                    ("SUBSTACK_COOKIE", SUBSTACK_COOKIE),
                    ("SUBSTACK_PUBLICATION_URL", SUBSTACK_PUBLICATION_URL),
                ) if not val
            ]
            logger.error(f"Missing Substack config: {missing}")
            raise ValueError(
                f"You must set SUBSTACK_COOKIE and SUBSTACK_PUBLICATION_URL in .env. Missing: {missing}"
            )

        # Parse your single "name=value" cookie string
        try:
            name, value = SUBSTACK_COOKIE.split("=", 1)
        except ValueError:
            raise ValueError("SUBSTACK_COOKIE must be in “name=value” form.")

        # Determine domain for Netscape cookie format
        domain = SUBSTACK_PUBLICATION_URL.replace("https://", "").replace("http://", "").lstrip("www.")

        # Compute a far-future expiration (or use 0 for a session cookie)
        # Here, we’ll set expiration to one year from now:
        expires = int(time.time()) + 365*24*3600

        # Build a single line in Netscape cookie format:
        # <domain> <tab> <TRUE|FALSE> <tab> <path> <tab> <TRUE|FALSE> <tab> <expiration> <tab> <name> <tab> <value>
        # We’ll say include subdomains = TRUE, path = "/", secure = FALSE (or TRUE if your cookie was Secure).
        netscape_line = "\t".join([
            domain,       # domain
            "TRUE",       # include subdomains
            "/",          # path
            "FALSE",      # secure flag (use "TRUE" if your cookie is Secure)
            str(expires), # expiration timestamp
            name,         # cookie name
            value         # cookie value
        ])

        # Write that to a temporary cookie file:
        tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".txt")
        tmp.write(b"# Netscape HTTP Cookie File\n")
        tmp.write(b"# Generated by substack_client.py\n")
        tmp.write(netscape_line.encode("utf-8") + b"\n")
        tmp.flush()
        cookies_path = tmp.name
        tmp.close()
        logger.info(f"Wrote temporary Netscape cookie file to {cookies_path}")

        # Initialize Api with that Netscape cookie file:
        self.api = Api(
            cookies_path=cookies_path,
            publication_url=SUBSTACK_PUBLICATION_URL
        )
        logger.info("Initialized python-substack Api client via generated cookies_path")

    def publish(self, body_md: str):
        lines = body_md.strip().split("\n")
        if len(lines) < 2 or not lines[0].startswith("# "):
            raise ValueError(
                "body_md must start with a level-1 heading (# Title) followed by a subtitle."
            )

        title = lines[0].lstrip("# ").strip()
        subtitle = lines[1].strip()
        remainder_md = "\n".join(lines[2:]).strip()

        post = Post(
            title=title,
            subtitle=subtitle,
            publication_url=SUBSTACK_PUBLICATION_URL
        )
        post.add({"type": "paragraph", "content": remainder_md})

        logger.info("Publishing Substack post via temp cookie file: %r", title)
        return self.api.post_publish(post.get_draft())

    def create_draft(self, body_md: str):
        lines = body_md.strip().split("\n")
        title = lines[0].lstrip("# ").strip()
        subtitle = lines[1].strip()
        remainder_md = "\n".join(lines[2:]).strip()

        post = Post(
            title=title,
            subtitle=subtitle,
            publication_url=SUBSTACK_PUBLICATION_URL
        )
        post.add({"type": "paragraph", "content": remainder_md})
        return self.api.post_draft(post.get_draft())

    def upload_asset(self, filepath: str) -> str:
        return self.api.upload_asset(filepath)
